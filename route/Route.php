<?php

namespace route;
use prototypes\Model;
use prototypes\View;
use redirect\Redirect;


class Route
{

	public static function direct()
	{

		// Небольщой костыль, столкнулся с проблемой отправки cookie из js,
		// как оказалось, что бы передавать cookie, нужно их с начала получить
		// от сервера, пришлось синхронизировать отсутствие cookie, передачей
		// собственного заголовка, с идентификатором сессии, и его объявлением в ручную,
		// с последующим заданием того же идентификатора в cookie браузера.
		// Но вместе с тем, это уязвимость. В реальном проекте, лучше сделать предзапрос из js.
		$headers = getallheaders();

		if(isset($headers['sessionid']) AND $headers['sessionid'] !== '' AND !isset($headers['Cookie']))
		{

			session_id($headers['sessionid']);

			header("Set-Cookie: PHPSESSID=". $headers['sessionid']);

		}

		session_start(); // Открываем сессию.

		$model = new Model(); // Получаем экземпляр модели, ее методы в дальнейшем нам понадобятся.
		$user = null; // Заране объявляем переменную user.

//		if(isset($_GET['im'])) debug($_SESSION); die();

		// Проверяем, еть ли у зашедшего в файлах сессии переменная user.
		if(!isset($_SESSION['user']))
		{
			// Если ее нет, регестрируем ползователя.
			// Метод registerUser возвращает уже записанный в базы хэш.
			$hash = $model->registerUser(getNormalizeAddressString(substr(parse_url($_SERVER['REQUEST_URI'])['path'], '1')));
			$_SESSION['user'] = $hash; // Его и запишем в переменную user.

		}
		else
		{
			/**
			 * Если переменая в файлах сессии есть, то проверим ее на действительность,
			 * ведь по всякому бывает, для этого, попробуем получить идентифмкатор пользователя
			 * по данному хешу.
			 */
			$isUser = $model->getUser($_SESSION['user']);

			// Далее проверим, пришол ли нам ответ с id.
			if(isset($isUser['id']))
			{

				// Если пришел, перепишем в ранее созданную переменную user.
				$user = $isUser;

			}
			else
			{

				/**
				 * В протином случае, пользователь, вероятнее всего,
				 * по каким то причинам был удален из базы данных,
				 * либо, нас пытаются обхитрить,
				 * в этом слушаче, удалим его данные из файлов сессии
				 * и перенаправим его сюда же, но уже пустым, для повторной регистрации.
				 * Случай не стандартный, но все может быть.
				 */
				unset($_SESSION['user']);
				header('Location: http://'.$_SERVER['HTTP_HOST'].'/'.getNormalizeAddressString(substr(parse_url($_SERVER['REQUEST_URI'])['path'], '1')));

			}

		}

		/**
		 * Если вопросы авторизации пройдены, перейдем к роутингу.
		 *
		 * Для начала разабьем строку запроса на составляющие,
		 * при помощи разделителя: '/', предварительно убрав слеш в конце,
		 * если он есть, при помощи вспомогательной функции getNormalizeAddressString.
		 */
		$breakArray = explode('/', getNormalizeAddressString(substr(parse_url($_SERVER['REQUEST_URI'])['path'], '1')));

		// И снова проверки. Для начала, посмотрим, не к корню ли обращается пользователь.
		// Если условие удовлетворится, отправим нашу корневую страницу.
		if($breakArray[0] !== '')
		{

			/**
			 * Пользователи не все одинаково умны, поэтому, стоит
			 * предусмотреть несколько вариантов развития событий.
			 * Кто то может указать 2 слеша в конце, сто приведет к созданию второго
			 * пустого значения в разбитом массиве строки запроса. Но не будем судить строго,
			 * и сочтем, что наш пользователь пытается перейти по ссылке, куда мы его и направим.
			 */
			if(count($breakArray) === 1 OR count($breakArray) === 2 AND $breakArray[1] === '')
			{

				// Перенаправим, передав ссылку, для перенаправление и id передающего.
				new Redirect($user, $breakArray[0]);

			}
			elseif(count($breakArray) === 2)
			{

				/**
				 * Если длинна массива равна 2, без "сюрпризов", то, вероятнее всего,
				 * пользователь пытается запросить функционал, помимо обычного редиректа.
				 * Так давайте проверим.
				 */

				// Составим имена контроллера и модели.
				$controllerName = ucfirst(mb_strtolower($breakArray[0])).'Controller';
				$modelName = ucfirst(mb_strtolower($breakArray[0])).'Model';

				// Составим полный путь к соответствующим файлам.
				$controllerPath = ROOT_SITE . 'controllers/' . $controllerName . '.php';
				$modelPath = ROOT_SITE . 'models/' . $modelName . '.php';

				// Проверим, существуют ли вовсе эти файлы.
				if(file_exists($controllerPath) AND file_exists($modelPath))
				{

					/**
					 * В случае успеха, будем обращаться к классам через пространство имен.
					 * Для этого, составим соответствующие пути.
					 */
					$namespaceController = 'controllers\\'.$controllerName;
					$namespaceModel = 'models\\'.$modelName;

					// Получим экземпляр контроллера.
					$controller = new $namespaceController(new $namespaceModel(), new View());

					// А теперь пришло время получить имя действия, запрошенного пользователем.
					$actionName = mb_strtolower($breakArray[1]) . 'Action';

					/**
					 * Само собой, теперь надо проверить, существует ли данное действие
					 * в нашем контроллере, пользователь мог элементарно ошибиться или
					 * перебирать все подряд, этого мы не узнаем, но точно дадим ему понять,
					 * что он не прав.
					 */
					if(method_exists($controller, $actionName))
					{
						/**
						 * Если все прошло успешно, вызовем запрошенное действие,
						 * передав прверенный через вспомогательную функцию normalize_POST,
						 * массив $_POST.
						 */
						$controller->$actionName(normalize_POST($_POST), $user);

					}
					else View::show_message('Ошибка 404', 'Кажется, такой страницы не существует. Пожалуйста, уточните данные.'); // Не сошлось? Страница не найдена, разве нет?

				}
				else View::show_message('Ошибка 404', 'Кажется, такой страницы не существует. Пожалуйста, уточните данные.');

			}
			else View::show_message('Ошибка 404', 'Кажется, такой страницы не существует. Пожалуйста, уточните данные.'); // Не сошлось? Страница не найдена, разве нет?

		}
		else View::root($_SERVER['HTTP_HOST'].'/', $breakArray); // Передадим нашу страницу.

	}

}